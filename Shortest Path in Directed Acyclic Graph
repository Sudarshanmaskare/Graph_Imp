///Three Solutions


Using Bellman-Ford [ TC = O(VE) ]
Using Dijkstra's Algorithm [ TC = O(E + Vlog(V)) ]
Topological Sort [ TC = O(V + E) ]




#include <bits/stdc++.h> 
#define INF INT_MAX 
using namespace std; 

void findTopoSort(int node, int vis[], stack<int> &st, vector<pair<int,int>> adj[]) {
    vis[node] = 1; 
    for(auto it : adj[node]) {
        if(!vis[it.first]) {
            findTopoSort(it.first, vis, st, adj); 
        }
    }
    st.push(node);
}


void shortestPath(int src, int N, vector<pair<int,int>> adj[]) 
{ 
	int vis[N] = {0};
	stack<int> st; 
	for (int i = 0; i < N; i++) 
		if (!vis[i]) 
			findTopoSort(i, vis, st, adj); 
			
	int dist[N]; 
	for (int i = 0; i < N; i++) 
		dist[i] = 1e9; 
	dist[src] = 0; 

	while(!st.empty()) 
	{  
		int node = st.top(); 
		st.pop(); 
 
		if (dist[node] != INF) {
		    for(auto it : adj[node]) {
		        if(dist[node] + it.second < dist[it.first]) {
		            dist[it.first] = dist[node] + it.second; 
		        }
		    }
		}
	} 

	for (int i = 0; i < N; i++) 
		(dist[i] == 1e9)? cout << "INF ": cout << dist[i] << " "; 
} 




/////for edges use dijigstra algo

int solve(vector<vector<int>>& edges, int start, int end) {
      priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> q;
    unordered_map<int, vector<pair<int, int>>> adj;
    for (int i = 0; i < edges.size(); ++i) {
        int u = edges[i][0];
        int v = edges[i][1];
        int w = edges[i][2];
        adj[u].push_back({v, w});
    }
    unordered_map<int, int> dist;
    dist[start] = 0;
    q.push({0, start});
    while (q.size()) {
        int u = q.top().second;
        int u_dist = q.top().first;
        q.pop();
        if (u_dist != dist[u]) continue;
        for (pair<int, int> p : adj[u]) {
            int v = p.first;
            int v_dist = p.second;
            if (dist.find(v) == dist.end() || dist[u] + v_dist < dist[v]) {
                dist[v] = dist[u] + v_dist;
                q.push({dist[v], v});
            }
        }
    }
    if (dist.find(end) == dist.end()) return -1;
    return dist[end];
}
